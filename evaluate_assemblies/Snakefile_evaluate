import pandas as pd
import shlex
import subprocess
from pathlib import Path
from Bio import SeqIO
import re

configfile: "config.yaml"

samples = pd.read_table(config["samples"]).set_index("sample", drop=False)

def get_genome(wildcards):
	return samples.loc[wildcards.sample, "assembly"]

def get_genome_prefix(wildcards):
	gen = samples.loc[wildcards.sample, "assembly"]
	return ''.join(gen.split('.')[:-1])

rule all:
	input:
		expand('evaluate_assembly/{sample}/ALEScore_{sample}.finished', sample=samples['sample']),
		expand('evaluate_assembly/{sample}/REAPR_{sample}.finished', sample=samples['sample']),
		expand('evaluate_assembly/{sample}/busco/BUSCO_{sample}.finished', sample=samples['sample'])

rule check_header_fasta:
	input:
		genome=get_genome
	output:
		'evaluate_assembly/{sample}/FACHECK_ok.txt'
	run:
		
		facheck = subprocess.call(["reapr", "facheck", "{}".format(input.genome)],  stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
		if facheck == 1:
			raise ValueError('\033[94m The header of assembly {} is not compatible with REAPR.\nPlease, execute reapr facheck and modify the file assemblies.tsv to point to assembly with corrected header! \033[0m \n\n\n To this y using command line: \033[96m reapr facheck <in.fa> [out_prefix] \033[0m'.format(input.genome))
		else:
			shell('touch {output}')


rule build_index_bowtie2:
	input:
		fasta=get_genome,
		fasta_ok='evaluate_assembly/{sample}/FACHECK_ok.txt'
	output:
		'evaluate_assembly/{sample}/{sample}.index_built'
	params:
		prefix=get_genome_prefix
	conda:
		"envs/myenv.yaml"
	shell:
		"bowtie2-build {input.fasta} {params.prefix} && touch {output}"

rule bowtie2:
	input:
		sample=[ config["fq1"], config["fq2"] ],
		index_bowtie2='evaluate_assembly/{sample}/{sample}.index_built'
	output:
		'evaluate_assembly/{sample}/{sample}.bam'
	log:
		'evaluate_assembly/logs/{sample}_bowtie2.log'
	params:
		index = get_genome_prefix,
		extra = "--end-to-end --very-sensitive"
	threads: config["threads"]
	conda:
		"envs/myenv.yaml"
	wrapper:
		"0.31.1/bio/bowtie2/align"

rule samtools_sort:
	input:
		'evaluate_assembly/{sample}/{sample}.bam'
	output:
		'evaluate_assembly/{sample}/{sample}.sorted.bam'
	params:
		"-m 4G"
	threads: config["threads"]
	conda:
		"envs/myenv.yaml"
	wrapper:
		"0.31.1/bio/samtools/sort"

rule samtools_index:
	input:
		'evaluate_assembly/{sample}/{sample}.sorted.bam'
	output:
		'evaluate_assembly/{sample}/{sample}.bam.bai'
	conda:
		"envs/myenv.yaml"
	wrapper:
		"0.31.1/bio/samtools/index"


rule evaluate_assembly_ALE:
        input:
                genome = get_genome,
		r = 'evaluate_assembly/{sample}/{sample}.sorted.bam'
        benchmark:
                'evaluate_assembly/benchmark/{sample}_ALE.log'
        output:
                'evaluate_assembly/{sample}/ALEScore_{sample}.finished'
        shell:"ALE --nout --metagenome {input.r} {input.genome} evaluate_assembly/{wildcards.sample}/ALEoutput.txt && touch {output}"

rule evaluate_assembly_REAPR:
	input:
		genome = get_genome,
		r = 'evaluate_assembly/{sample}/{sample}.sorted.bam',
		bai = 'evaluate_assembly/{sample}/{sample}.bam.bai'
	benchmark:
		'evaluate_assembly/benchmark/{sample}_REAPR.log'
	output:
		'evaluate_assembly/{sample}/REAPR_{sample}.finished'
	params:
		prefix=get_genome_prefix
	singularity:
		"docker://rodtheo/genomics/reapr-v1.0.18"
	conda:
		"envs/myenv.yaml"
	shell:
		"reapr pipeline {input.genome} {input.r} evaluate_assembly/{wildcards.sample}/reapr_results && touch {output}"
#		genome_fachecked = '{}_fachecked'.format(params.prefix)
#		facheck = subprocess.call(["reapr", "facheck", "{}".format(input.genome)],  stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
#		print(facheck)
#		if facheck == 1:
#			genome_fachecked = '{}_fachecked'.format(params.prefix)
#			facheck = subprocess.check_output(["reapr", "facheck", "{}".format(input.genome), "{}".format(genome_fachecked)], shell=False,stderr=subprocess.STDOUT)
#			print("Repairing fasta header with facheck")
#			shell("reapr pipeline {genome_fachecked}.fa {input.r} evaluate_assembly/{wildcards.sample}/reapr_results && touch {output}")
#		else:
#			shell("reapr pipeline {input.genome} {input.r} evaluate_assembly/{wildcards.sample}/reapr_results && touch {output}")
			
		#'reapr pipeline {input.genome} {input.r} evaluate_assembly/{wildcards.sample}/reapr_results && touch {output}'

rule busco:
	input:
		genome = get_genome,
		lineage = config["lineage"]
	output:
		'evaluate_assembly/{sample}/busco/BUSCO_{sample}.finished'
	benchmark: "evaluate_assembly/benchmark/{sample}_BUSCO.log"
        params: species=config["species_augustus"]
        threads: config["threads"]
	conda: "envs/myenv.yaml"
        shell: 'run_BUSCO.py -i {input.genome} -o {wildcards.sample} -l {input.lineage} --cpu 10 --species {params.species} --mode genome && mv run_{wildcards.sample} evaluate_assembly/{wildcards.sample}/ && touch {output}'

