import pandas as pd
import shlex
import subprocess
from pathlib import Path
from Bio import SeqIO
import re

configfile: "config.yaml"

samples = pd.read_table(config["samples"]).set_index("sample", drop=False)

def get_genome(wildcards):
	return samples.loc[wildcards.sample, "assembly"]

def get_genome_prefix(wildcards):
	gen = samples.loc[wildcards.sample, "assembly"]
	return ''.join(gen.split('.')[:-1])

rule all:
	input:
		expand('evaluate_assembly/{sample}/ALEScore_{sample}.finished', sample=samples['sample']),
		expand('evaluate_assembly/{sample}/REAPR_{sample}.finished', sample=samples['sample']),
		expand('evaluate_assembly/{sample}/busco/BUSCO_{sample}.finished', sample=samples['sample'])

rule check_header_fasta:
	input:
		genome=get_genome
	output:
		'evaluate_assembly/{sample}/FACHECK_ok.txt'
	run:
		bad_header = False
		print("HEADER")
		with open(input.genome, "r") as ingenome:
			for record in SeqIO.parse(ingenome, "fasta"):
				print(record.description)
				# if len(str(record.id).split(" ")) > 1:
				if re.search(r"\s", str(record.description)):
					print("BAD HEADER")
					bad_header = True
		if bad_header:
			print('\033[94m The header of assembly {} is not compatible with REAPR.\nPlease, execute reapr facheck and modify the file assemblies.tsv to point to assembly with corrected header! \033[0m \n\n\n To this y using command line: \033[96m reapr facheck <in.fa> [out_prefix] \033[0m'.format(input.genome))
			sequences = []
			with open(input.genome, "r") as ingenome:
				for record in SeqIO.parse(ingenome, "fasta"):
					header = str(record.description)
					record.id = "_".join(header.split(" "))
					record.description=""
					print(record.id)
					sequences.append(record)
			source = Path(input.genome)
			destination = Path(input.genome+".bkp")
			with destination.open(mode="xb") as fid:
				fid.write(source.read_bytes())
			with open(str(source), "w") as outgenome:
				SeqIO.write(sequences, outgenome, "fasta")
			shell('touch {output}')
		else:
			shell('touch {output}')


rule build_index_bowtie2:
	input:
		fasta=get_genome,
		fasta_ok='evaluate_assembly/{sample}/FACHECK_ok.txt'
	output:
		'evaluate_assembly/{sample}/{sample}.index_built'
	params:
		prefix=get_genome_prefix
	conda:
		"envs/myenv.yaml"
	shell:
		"bowtie2-build {input.fasta} {params.prefix} && touch {output}"

rule bowtie2:
	input:
		sample=[ config["fq1"], config["fq2"] ],
		index_bowtie2='evaluate_assembly/{sample}/{sample}.index_built'
	output:
		'evaluate_assembly/{sample}/{sample}.bam'
	log:
		'evaluate_assembly/logs/{sample}_bowtie2.log'
	params:
		index = get_genome_prefix,
		extra = "--end-to-end --very-sensitive"
	threads: config["threads"]
	conda:
		"envs/myenv.yaml"
	wrapper:
		"0.31.1/bio/bowtie2/align"

rule samtools_sort:
	input:
		'evaluate_assembly/{sample}/{sample}.bam'
	output:
		'evaluate_assembly/{sample}/{sample}.sorted.bam'
	params:
		"-m 4G"
	threads: config["threads"]
	conda:
		"envs/myenv.yaml"
	wrapper:
		"0.31.1/bio/samtools/sort"

rule samtools_index:
	input:
		'evaluate_assembly/{sample}/{sample}.sorted.bam'
	output:
		'evaluate_assembly/{sample}/{sample}.bam.bai'
	conda:
		"envs/myenv.yaml"
	wrapper:
		"0.31.1/bio/samtools/index"


rule evaluate_assembly_ALE:
        input:
                genome = get_genome, r = 'evaluate_assembly/{sample}/{sample}.sorted.bam'
        benchmark: "evaluate_assembly/benchmark/{sample}_ALE.log"
        output: "evaluate_assembly/{sample}/ALEScore_{sample}.finished"
        shell: "docker run -v `pwd`:/dir --rm rodtheo/genomics:eval_assem_ale_reapr ALE --nout --metagenome /dir/{input.r} /dir/{input.genome} /dir/evaluate_assembly/{wildcards.sample}/ALEoutput.txt && touch {output}"

rule evaluate_assembly_REAPR:
	input:
		genome = get_genome,
		r = 'evaluate_assembly/{sample}/{sample}.sorted.bam',
		bai = 'evaluate_assembly/{sample}/{sample}.bam.bai'
	benchmark:
		'evaluate_assembly/benchmark/{sample}_REAPR.log'
	output:
		'evaluate_assembly/{sample}/REAPR_{sample}.finished'
	params:
		prefix=get_genome_prefix
	shell:
		"docker run -v `pwd`:/dir --rm rodtheo/genomics:eval_assem_ale_reapr reapr pipeline /dir/{input.genome} /dir/{input.r} /dir/evaluate_assembly/{wildcards.sample}/reapr_results && touch {output}"
#		genome_fachecked = '{}_fachecked'.format(params.prefix)
#		facheck = subprocess.call(["reapr", "facheck", "{}".format(input.genome)],  stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
#		print(facheck)
#		if facheck == 1:
#			genome_fachecked = '{}_fachecked'.format(params.prefix)
#			facheck = subprocess.check_output(["reapr", "facheck", "{}".format(input.genome), "{}".format(genome_fachecked)], shell=False,stderr=subprocess.STDOUT)
#			print("Repairing fasta header with facheck")
#			shell("reapr pipeline {genome_fachecked}.fa {input.r} evaluate_assembly/{wildcards.sample}/reapr_results && touch {output}")
#		else:
#			shell("reapr pipeline {input.genome} {input.r} evaluate_assembly/{wildcards.sample}/reapr_results && touch {output}")

		#'reapr pipeline {input.genome} {input.r} evaluate_assembly/{wildcards.sample}/reapr_results && touch {output}'

rule busco:
	input:
		genome = get_genome,
		lineage = config["lineage"]
	output:
		'evaluate_assembly/{sample}/busco/BUSCO_{sample}.finished'
	benchmark: "evaluate_assembly/benchmark/{sample}_BUSCO.log"
        params: species=config["species_augustus"]
        threads: config["threads"]
	conda: "envs/myenv.yaml"
        shell: 'run_BUSCO.py -i {input.genome} -o {wildcards.sample} -l {input.lineage} --cpu 10 --species {params.species} --mode genome && mv run_{wildcards.sample} evaluate_assembly/{wildcards.sample}/ && touch {output}'
